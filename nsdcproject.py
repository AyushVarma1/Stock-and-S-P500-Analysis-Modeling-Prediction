# -*- coding: utf-8 -*-
"""NSDCProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xSSDGU-8dQdVRQOBQPQPFBveFtbHOGMq
"""

import yfinance as yf
import pandas as pd
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
import seaborn as sns
import time
from sklearn.linear_model import LinearRegression
import statsmodels.api as sm

"""**S&P 500**"""

sp_path = "/content/drive/MyDrive/NSDC/Data/sp500.csv"
sp_df = pd.read_csv(sp_path)

# Convert the date column to datetime and set as index
# Assuming your CSV has a column named 'Date'

def line_plot(df, title="S&P 500 Closing Price"):

    plt.figure(figsize=(12, 6))
    df['Close'].plot(linewidth=2)
    plt.title(title, fontsize=16)
    plt.xlabel('Date', fontsize=14)
    plt.ylabel('Price ($)', fontsize=14)
    plt.legend(loc='best', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

line_plot(sp_df)

"""**Communication Sector**"""

comm_path = "/content/drive/MyDrive/NSDC/Data/communications.csv"
communications_df = pd.read_csv(comm_path)

def plot_sector_stocks(sector_df, title="Sector Stocks Closing Prices"):

    if 'Date' in sector_df.columns:
        sector_df['Date'] = pd.to_datetime(sector_df['Date'])
        sector_df = sector_df.set_index('Date')

    plt.figure(figsize=(14, 7))
    stocks = sector_df['Symbol'].unique()

    for stock in stocks:
        stock_data = sector_df[sector_df['Symbol'] == stock]
        plt.plot(stock_data.index, stock_data['Close'], linewidth=2, label=stock)

    plt.title(title, fontsize=16)
    plt.xlabel('Date', fontsize=14)
    plt.ylabel('Closing Price ($)', fontsize=14)
    plt.legend(loc='best', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

plot_sector_stocks(communications_df, title="Communications Stocks Closing Prices")

"""**Consumer Discretionary Sector**"""

con_path = "/content/drive/MyDrive/NSDC/Data/consumer_discretionary.csv"
consumer_discretionary_df = pd.read_csv(con_path)

plot_sector_stocks(consumer_discretionary_df, title="Consumer Discretionary Stocks Closing Prices")

"""**Consumer Staples Sector**"""

consumer_path = "/content/drive/MyDrive/NSDC/Data/consumer_staples.csv"
consumer_staples_df = pd.read_csv(consumer_path)

plot_sector_stocks(consumer_staples_df, title="Consumer Staples Stocks Closing Prices")

"""**Energy Sector**"""

energy_path = "/content/drive/MyDrive/NSDC/Data/energy.csv"
energy_df = pd.read_csv(energy_path)

plot_sector_stocks(energy_df, title="Energy Stocks Closing Prices")

"""**Finacials Sector**"""

financials_path = "/content/drive/MyDrive/NSDC/Data/financials.csv"
financials_df = pd.read_csv(financials_path)

plot_sector_stocks(financials_df, title="Financials Stocks Closing Prices")

"""**Healthcare Sector**"""

healthcare_path = "/content/drive/MyDrive/NSDC/Data/healthcare.csv"
healthcare_df = pd.read_csv(healthcare_path)

plot_sector_stocks(healthcare_df, title="Healthcare Stocks Closing Prices")

"""**Industrials Sector**"""

industrials_path = "/content/drive/MyDrive/NSDC/Data/industrials.csv"
industrials_df = pd.read_csv(industrials_path)

plot_sector_stocks(industrials_df, title="Industrials Stocks Closing Prices")

"""**Materials Sector**"""

materials_path = "/content/drive/MyDrive/NSDC/Data/materials.csv"
materials_df = pd.read_csv(materials_path)

plot_sector_stocks(materials_df, title="Materials Stocks Closing Prices")

"""**Real Estate Sector**"""

real_estate_path = "/content/drive/MyDrive/NSDC/Data/realestate.csv"
real_estate_df = pd.read_csv(real_estate_path)

plot_sector_stocks(real_estate_df, title="Real Estate Stocks Closing Prices")

"""**Tech Sector**"""

tech_path = "/content/drive/MyDrive/NSDC/Data/tech.csv"
tech_df = pd.read_csv(tech_path)

plot_sector_stocks(tech_df, title="Tech Stocks Closing Prices")

"""**Utilities Sector**"""

utilities_path = "/content/drive/MyDrive/NSDC/Data/utilities.csv"
utilities_df = pd.read_csv(utilities_path)

plot_sector_stocks(utilities_df, title="Utilities Stocks Closing Prices")

"""**Multiple Linear Regression**"""

def mult_regressions(sector_df, sp_df, sector_name):
    """
    Performs multiple linear regression of sector stock prices against the S&P 500 price.

    Args:
        sector_df (pd.DataFrame): DataFrame containing the sector stock data with 'Date', 'Symbol', and 'Close' columns.
        sp_df (pd.DataFrame): DataFrame containing the S&P 500 data with a 'Date' and 'Close' column.
        sector_name (str): The name of the sector for plotting and printing.

    Returns:
        tuple: A tuple containing the statsmodels regression model result and the combined data DataFrame.
    """
    # Convert dates to datetime for proper alignment, handling potential timezones
    # Adding utc=True to handle timezone-aware datetimes
    sector_df['Date'] = pd.to_datetime(sector_df['Date'], utc=True)

    unique_symbols = sector_df['Symbol'].unique()
    print(f"Found {len(unique_symbols)} unique stocks in {sector_name} sector")

    # Ensure S&P 500 date is also handled as datetime and set as index if not already
    if not isinstance(sp_df.index, pd.DatetimeIndex):
        sp_df['Date'] = pd.to_datetime(sp_df['Date'], utc=True) # Also set utc=True for SP500
        sp_df = sp_df.set_index('Date')

    # Create a combined DataFrame with DatetimeIndex
    # Ensure index is created from the sector_df dates after conversion to handle their time range
    all_data = pd.DataFrame(index=pd.DatetimeIndex([]))

    for symbol in unique_symbols:
        stock_data = sector_df[sector_df['Symbol'] == symbol]
        # When creating the series, use the converted datetime index
        stock_series = pd.Series(
            stock_data['Close'].values,
            index=stock_data['Date']
        )
        all_data[symbol] = stock_series

    # Ensure SP500 data is aligned with the combined index
    # Reindex sp_series to match the index of all_data before merging
    if 'Close' in sp_df.columns:
        sp_series = sp_df['Close']
    else:
        sp_series = sp_df.iloc[:, 0]

    # Align SP500 data by index with all_data, using nearest available data if needed
    all_data['SP500'] = sp_series.reindex(all_data.index, method='nearest')


    X = all_data.drop('SP500', axis=1)
    y = all_data['SP500']

    # Check if X is empty after dropping NaNs
    if X.empty:
         print(f"Independent variables are empty after dropping NaNs for {sector_name} sector.")
         return None, None

    # Add a constant to the independent variables
    X = sm.add_constant(X)

    # Perform the regression
    model = sm.OLS(y, X).fit()

    print(model.summary())

    print(f"\n--- {sector_name} Sector Regression Results ---")
    print(f"R-squared: {model.rsquared:.4f}")
    print(f"Adjusted R-squared: {model.rsquared_adj:.4f}")
    print("\nStock Coefficients:")

    # Exclude 'const' from coefficients display
    coefs = model.params[1:]
    pvalues = model.pvalues[1:] # Also get pvalues excluding 'const'

    # Sort coefficients for better visualization in the bar chart
    sorted_coefs = coefs.sort_values(ascending=False)


    for stock, coef in sorted_coefs.items():
        print(f"{stock}: {coef:.4f} (p-value: {pvalues[stock]:.4f})")


    # Plotting section - ensure there is enough data points for plotting
    if len(all_data) >= 2:
        # Scatter plot of stocks vs S&P 500
        plt.figure(figsize=(12, 8))

        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                 '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']

        # Iterate through independent variables for plotting
        for i, stock in enumerate(X.columns):
            if stock == 'const':
                continue

            color = colors[i % len(colors)]

            # Ensure there's enough data for scatter and line plots for this specific stock
            if len(all_data[stock].dropna()) >= 2 and len(all_data['SP500'].dropna()) >= 2:
                 plt.scatter(all_data[stock], all_data['SP500'],
                           alpha=0.7, label=stock, color=color)

                 # regression line
                 # Use only non-NaN data for polyfit
                 valid_indices = all_data[[stock, 'SP500']].dropna().index
                 if len(valid_indices) >= 2:
                     slope, intercept = np.polyfit(all_data.loc[valid_indices, stock],
                                                   all_data.loc[valid_indices, 'SP500'], 1)
                     # Use the min/max of the actual stock data for the line
                     x_range = np.linspace(all_data[stock].min(), all_data[stock].max(), 100)
                     plt.plot(x_range, intercept + slope * x_range,
                             linestyle='--', color=color, alpha=0.7)


        plt.title(f'{sector_name} Sector Stocks vs S&P 500')
        plt.xlabel('Stock Closing Price')
        plt.ylabel('S&P 500 Closing Price')
        plt.grid(alpha=0.3)
        plt.legend(loc='best')
        plt.tight_layout()
        plt.show()

        # actual vs predicted plot
        plt.figure(figsize=(10, 6))
        y_pred = model.predict(X)
        plt.scatter(y, y_pred, alpha=0.5)

        # Ensure the min/max calculation is robust if y has very few unique values
        if y.min() is not None and y.max() is not None and y.min() < y.max():
             plt.plot([y.min(), y.max()], [y.min(), y.max()], 'r--')

        plt.title(f'{sector_name} Sector: Actual vs Predicted S&P 500')
        plt.xlabel('Actual S&P 500')
        plt.ylabel('Predicted S&P 500')
        plt.grid(alpha=0.3)
        plt.tight_layout()
        plt.show()

        # Bar chart of stock coefficients
        plt.figure(figsize=(10, 6))
        # Use the already sorted coefficients
        colors = ['green' if c > 0 else 'red' for c in sorted_coefs]
        plt.bar(sorted_coefs.index, sorted_coefs.values, color=colors)
        plt.title(f'{sector_name} Stock Influence on S&P 500')
        plt.xlabel('Stock')
        plt.ylabel('Coefficient')
        plt.xticks(rotation=45, ha='right') # Rotate labels and align them to the right
        plt.grid(axis='y', alpha=0.3)
        plt.tight_layout()
        plt.show()


    return model, all_data

"""**Comparing S&P500 to the Communications Sector**"""

mult_regressions(communications_df, sp_df, "Communications")

"""**Comparing S&P500 to the Consumer Discretionary Sector**"""

mult_regressions(consumer_discretionary_df, sp_df, "Consumer Discretionary")

"""**Comparing S&P500 to the Consumer Staples Sector**"""

mult_regressions(consumer_staples_df, sp_df, "Consumer Staples")

"""**Comparing S&P500 to the Energy Sector**"""

mult_regressions(energy_df, sp_df, "Energy")

"""**Comparing S&P500 to the Financials Sector**"""

mult_regressions(financials_df, sp_df, "Financials")

"""**Comparing S&P500 to the Healthcare Sector**"""

mult_regressions(healthcare_df, sp_df, "Healthcare")

"""**Comparing S&P500 to the Industrials Sector**"""

mult_regressions(industrials_df, sp_df, "Industrials")

"""**Comparing S&P500 to the Materials Sector**"""

mult_regressions(materials_df, sp_df, "Materials")

"""**Comparing S&P500 to the Real Estate Sector**"""

mult_regressions(real_estate_df, sp_df, "Real Estate")

"""**Comparing S&P500 to the Tech Sector**"""

mult_regressions(tech_df, sp_df, "Tech")

"""**Comparing S&P500 to the Utilities Sector**"""

mult_regressions(utilities_df, sp_df, "Utilities")

"""**Bar Graph of R^2 Values**"""

def plot_rsquared_by_sector(sector_results):
    """
    Create a bar graph of R² values grouped by sector and ordered from highest to lowest.

    Parameters:
    sector_results - Dictionary with sector names as keys and regression results as values
                    Each value should be a tuple (model, data_df) where model is the statsmodels
                    regression result object

    Returns:
    None (displays the plot)
    """
    # Extract R² values from each sector's model
    r_squared_values = {}
    for sector, (model, _) in sector_results.items():
        # Skip any sectors with failed models
        if model is None:
            continue
        r_squared_values[sector] = model.rsquared

    # Sort sectors by R² value (descending)
    sorted_sectors = sorted(r_squared_values.items(), key=lambda x: x[1], reverse=True)

    # Create lists for plotting
    sector_names = [item[0] for item in sorted_sectors]
    r_squared = [item[1] for item in sorted_sectors]

    # Create the bar plot
    plt.figure(figsize=(12, 8))

    # Create bars with a gradient color based on R² value
    colors = plt.cm.viridis(np.linspace(0.1, 0.9, len(r_squared)))

    bars = plt.bar(sector_names, r_squared, color=colors)

    # Add value labels on top of each bar
    for bar, value in zip(bars, r_squared):
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                f'{value:.4f}', ha='center', va='bottom', rotation=0)

    # Set title and labels
    plt.title('R² Values by Sector (Ordered Highest to Lowest)', fontsize=16)
    plt.xlabel('Sector', fontsize=14)
    plt.ylabel('R² Value', fontsize=14)
    plt.ylim(0, max(r_squared) * 1.15)  # Add 15% space above highest bar for labels

    # Add grid for easier reading
    plt.grid(axis='y', alpha=0.3)

    # Rotate x-axis labels for better readability if many sectors
    if len(sector_names) > 5:
        plt.xticks(rotation=45, ha='right')

    plt.tight_layout()
    plt.show()

# Example usage:
"""
# First run your regression on each sector
sector_results = {}

# Run regression for each sector
sectors = {
    "Technology": tech_df,
    "Healthcare": healthcare_df,
    "Financial": financial_df,
    # Add more sectors as needed
}

for sector_name, sector_data in sectors.items():
    model, data = mult_regression(sector_data, sp_df, sector_name)
    sector_results[sector_name] = (model, data)

# Then plot the R² comparison
plot_rsquared_by_sector(sector_results)
"""

# First run your regression on each sector
sector_results = {}

# Run regression for each sector
sectors = {
    "Technology": tech_df,
    "Healthcare": healthcare_df,
    "Financial": financials_df,
    "Communications": communications_df,
    "Consumer Discretionary": consumer_discretionary_df,
    "Consumer Staples": consumer_staples_df,
    "Energy": energy_df,
    "Industrials": industrials_df,
    "Materials": materials_df,
    "Real Estate": real_estate_df,
    "Utilities": utilities_df,

}

for sector_name, sector_data in sectors.items():
    # Capture the returned model object directly
    model = mult_regressions(sector_data, sp_df, sector_name)
    # Store the model object in the dictionary
    sector_results[sector_name] = model

# Then plot the R² comparison
plot_rsquared_by_sector(sector_results)